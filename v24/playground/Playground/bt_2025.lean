
namespace bt_2025

/-
Sorry, Aristotle was unable to complete the task in time.
-/
/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
-/

import Mathlib

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

/-
There are infinitely many pairs of positive integers $(d, n)$ such that $d$ divides $n$ but $\binom{2d}{d}$ does not divide $\binom{2n}{n}$.
-/
def question1_statement : Prop :=
  Set.Infinite { p : ℕ × ℕ | p.1 ∣ p.2 ∧ ¬ (Nat.centralBinom p.1 ∣ Nat.centralBinom p.2) }

theorem question1_true : question1_statement := by
  -- Let $d=3$. Then $\binom{2d}{d} = \binom{6}{3} = 20$.
  have h_binom_3 : Nat.choose (2 * 3) 3 = 20 := by rfl

  -- By Kummer's Theorem, the exponent of the highest power of 5 dividing $\binom{2n_k}{n_k}$ is equal to the number of carries when adding $n_k$ to itself in base 5.
  have h_kummer : ∀ k : ℕ,
    Nat.factorization (Nat.choose (2 * (27 * 5 ^ k)) (27 * 5 ^ k)) 5 = 0 := by
    intro k
    rw [ Nat.factorization_def _ (by norm_num) ]
    have := Fact.mk ( by decide : Nat.Prime 5 )
    rw [ padicValNat_choose ]
    simp only [
      Finset.card_eq_zero,
      Finset.filter_eq_empty_iff,
      Finset.mem_Ico,
      not_le,
      and_imp
    ]
    intro x a a_1
    rotate_right
    exact k + 3;
    · rw [two_mul]
      norm_num [ Nat.add_mod, Nat.mul_mod ]
      rcases x with ( _ | _ | _ | _ | x ) <;> norm_num [ Nat.pow_succ', ← mul_assoc, Nat.mul_mod_mul_left ] at *;
      · cases k <;> norm_num [ Nat.pow_mod, Nat.mul_mod ] at *;
      · rcases k with ( _ | _ | k ) <;> norm_num [ Nat.pow_succ', ← mul_assoc, Nat.mul_mod ] at *;
      · rcases k with ( _ | _ | _ | k ) <;> norm_num [ Nat.pow_succ', ← mul_assoc, Nat.mul_mod ] at *;
      · rw [ show 5 ^ k = 5 ^ ( x + 1 ) * 5 ^ ( k - ( x + 1 ) ) by rw [ ← pow_add, Nat.add_sub_of_le ( by linarith ) ] ] ; ring_nf;
        norm_num [ mul_assoc, Nat.mul_mod_mul_left ];
        rcases u : k - ( 1 + x ) with ( _ | _ | _ | _ | u ) <;> norm_num [ Nat.pow_succ', ← mul_assoc, Nat.mul_mod, u ];
    · grind
    · apply Nat.log_lt_of_lt_pow (by positivity)
      ring_nf
      gcongr
      norm_num

  -- Since $20$ is a multiple of $5$, we have $20 \nmid \binom{2n_k}{n_k}$.
  have h_not_div_20 : ∀ k : ℕ, ¬(20 ∣ Nat.choose (2 * (27 * 5 ^ k)) (27 * 5 ^ k)) := by
    intro k hk
    specialize h_kummer k
    simp_all +decide [ Nat.factorization_eq_zero_iff ]
    apply h_kummer.elim <;> grind [Nat.choose_pos]

  exact Set.infinite_of_injective_forall_mem
    ( show Function.Injective ( fun k ↦ ⟨ 3, 27 * 5^k ⟩ ) from by intros m n hmn; simpa using hmn )
    fun k ↦ ⟨ ⟨ 9 * 5^k, by ring ⟩, by simpa [ h_binom_3 ] using h_not_div_20 k ⟩

/-
The polynomial $x^{46} + 69x + 2025$.
-/
noncomputable def question2_poly : Polynomial ℤ := Polynomial.X ^ 46 + 69 * Polynomial.X + 2025

/-
The polynomial $x^{46} + 69x + 2025$ has no integer roots.
-/
lemma question2_no_int_root : ∀ x : ℤ, question2_poly.eval x ≠ 0 := by
  -- We'll use cases on the value of x to handle each interval separately.
  intro x
  by_cases hx : x ≥ 0;
  · unfold question2_poly; norm_num; nlinarith [ sq_nonneg ( x ^ 23 ) ] ;
  · -- Since $x < 0$, we can write $x = -y$ where $y > 0$.
    obtain ⟨y, hy⟩ : ∃ y : ℤ, x = -y ∧ 0 < y := by
      exact ⟨ -x, by ring, by linarith ⟩;
    unfold question2_poly; aesop;
    nlinarith [ pow_le_pow_left₀ ( by linarith ) ( show y ≥ 2 by by_contra; interval_cases y ; trivial ) 45 ]

/-
The polynomial $x^{46} + 69x + 2025$ modulo 3 is $x^{46}$.
-/
lemma question2_mod_3 : question2_poly.map (Int.castRingHom (ZMod 3)) = Polynomial.X ^ 46 := by
  unfold question2_poly;
  norm_num [ Polynomial.ext_iff ];
  intro n; erw [ Polynomial.coeff_C, Polynomial.coeff_X ] ; aesop;

/-
If $x^{46} + 69x + 2025$ is reducible, it has a factor of degree 1.
-/
lemma question2_reducible_implies_degree_one_factor (h_red : ¬ Irreducible question2_poly) :
  ∃ g : Polynomial ℤ, g ∣ question2_poly ∧ g.degree = 1 := by
    -- Since the polynomial is reducible, it can be factored into two non-constant polynomials.
    obtain ⟨f, g, hf, hg, hfg⟩ : ∃ f g : Polynomial ℤ, f.degree > 0 ∧ g.degree > 0 ∧ f * g = question2_poly := by
      rw [ irreducible_iff ] at h_red ; aesop;
      specialize h_red ( by rintro h; exact absurd ( Polynomial.degree_eq_zero_of_isUnit h ) ( by erw [ Polynomial.degree_add_C ] <;> repeat ( first | erw [ Polynomial.degree_add_eq_left_of_degree_lt ] | erw [ Polynomial.degree_C ] ) <;> norm_num ) ) ; aesop;
      refine' ⟨ w, _, w_1, _, rfl ⟩;
      · contrapose! left_1;
        rw [ Polynomial.eq_C_of_degree_le_zero left_1 ] at left ⊢;
        replace left := congr_arg ( fun p => Polynomial.coeff p 46 ) left ; norm_num [ Polynomial.coeff_C, Polynomial.coeff_X, question2_poly ] at left;
        exact Polynomial.isUnit_C.mpr ( isUnit_of_mul_eq_one _ _ left.symm );
      · contrapose! right;
        rw [ Polynomial.eq_C_of_degree_le_zero right ] at left ⊢;
        replace left := congr_arg ( fun p => Polynomial.coeff p 46 ) left ; norm_num [ Polynomial.coeff_eq_zero_of_natDegree_lt ] at left;
        exact Polynomial.isUnit_C.mpr ( isUnit_of_dvd_one <| by erw [ show question2_poly.coeff 46 = 1 by { unfold question2_poly; norm_num [ Polynomial.coeff_X, Polynomial.coeff_C, mul_add ] } ] at left; aesop );
    -- Modulo 3, $f$ and $g$ are of the form $x^k$ and $x^{46-k}$ respectively, since $f * g = x^{46}$.
    have hfg_mod_3 : (f.map (Int.castRingHom (ZMod 3))) * (g.map (Int.castRingHom (ZMod 3))) = Polynomial.X ^ 46 := by
      rw [ ← Polynomial.map_mul, hfg, eq_comm ];
      exact?;
    -- If both $k \geq 2$ and $46 - k \geq 2$, then $3 \mid g_0$, $3 \mid g_1$, $3 \mid h_0$, $3 \mid h_1$.
    by_cases hk : (f.map (Int.castRingHom (ZMod 3))).degree ≥ 2 ∧ (g.map (Int.castRingHom (ZMod 3))).degree ≥ 2;
    · -- If both $k \geq 2$ and $46 - k \geq 2$, then $3 \mid g_0$, $3 \mid g_1$, $3 \mid h_0$, $3 \mid h_1$, contradicting $f_1 = 69$.
      have h_contra : (f.coeff 0) % 3 = 0 ∧ (f.coeff 1) % 3 = 0 ∧ (g.coeff 0) % 3 = 0 ∧ (g.coeff 1) % 3 = 0 := by
        have h_contra : (f.map (Int.castRingHom (ZMod 3))).coeff 0 = 0 ∧ (f.map (Int.castRingHom (ZMod 3))).coeff 1 = 0 ∧ (g.map (Int.castRingHom (ZMod 3))).coeff 0 = 0 ∧ (g.map (Int.castRingHom (ZMod 3))).coeff 1 = 0 := by
          have hfg_mod_3 : (f.map (Int.castRingHom (ZMod 3))) ∣ Polynomial.X ^ 46 ∧ (g.map (Int.castRingHom (ZMod 3))) ∣ Polynomial.X ^ 46 := by
            exact ⟨ hfg_mod_3 ▸ dvd_mul_right _ _, hfg_mod_3 ▸ dvd_mul_left _ _ ⟩;
          have hfg_mod_3 : ∀ {p : Polynomial (ZMod 3)}, p ∣ Polynomial.X ^ 46 → p.degree ≥ 2 → p.coeff 0 = 0 ∧ p.coeff 1 = 0 := by
            intros p hp hp_deg
            have hp_form : ∃ k : ℕ, p = Polynomial.C (p.leadingCoeff) * Polynomial.X ^ k := by
              rw [ dvd_prime_pow ] at hp;
              · rcases hp with ⟨ k, hk₁, hk₂ ⟩ ; obtain ⟨ u, hu ⟩ := hk₂.symm; use k; aesop;
                rcases Polynomial.isUnit_iff.mp u.isUnit with ⟨ k, hk ⟩ ; aesop;
                rw [ ← right_2, Polynomial.leadingCoeff_C ] ; ring;
              · exact Polynomial.prime_X;
            rcases hp_form with ⟨ k, hk ⟩ ; rw [ hk ] ; rcases k with ( _ | _ | k ) <;> norm_num [ Polynomial.coeff_eq_zero_of_natDegree_lt ] at *;
            · rw [ hk ] at hp_deg; rw [ Polynomial.degree_C ] at hp_deg <;> norm_num at hp_deg;
              intro h; simp +decide [ h ] at hp_deg;
            · rw [ hk ] at hp_deg;
              by_cases h : p.leadingCoeff = 0 <;> simp +decide [ h ] at hp_deg ⊢;
          aesop;
        erw [ Polynomial.coeff_map, Polynomial.coeff_map, Polynomial.coeff_map, Polynomial.coeff_map ] at h_contra ; aesop;
        · erw [ ZMod.intCast_zmod_eq_zero_iff_dvd ] at * ; aesop;
        · erw [ ZMod.intCast_zmod_eq_zero_iff_dvd ] at * ; aesop;
        · erw [ ZMod.intCast_zmod_eq_zero_iff_dvd ] at * ; aesop;
        · erw [ ZMod.intCast_zmod_eq_zero_iff_dvd ] at * ; aesop;
      replace hfg := congr_arg ( fun p => p.coeff 1 ) hfg ; simp_all +decide [ Polynomial.coeff_mul ];
      norm_num [ Finset.Nat.sum_antidiagonal_succ, Polynomial.coeff_one, Polynomial.coeff_X, question2_poly ] at hfg;
      exact absurd ( congr_arg ( · % 9 ) hfg ) ( by obtain ⟨ k, hk ⟩ := h_contra.1; obtain ⟨ l, hl ⟩ := h_contra.2.1; obtain ⟨ m, hm ⟩ := h_contra.2.2.1; obtain ⟨ n, hn ⟩ := h_contra.2.2.2; push_cast [ hk, hl, hm, hn ] ; ring_nf; norm_num [ Int.add_emod, Int.mul_emod ] );
    · -- Since $k < 2$ or $46 - k < 2$, we have $\deg(f) = 1$ or $\deg(g) = 1$.
      have h_deg : (f.degree = 1) ∨ (g.degree = 1) := by
        contrapose! hk; aesop;
        · erw [ Polynomial.degree_map_eq_of_leadingCoeff_ne_zero ] <;> norm_num;
          · exact le_of_not_gt fun h => left <| by rw [ Polynomial.degree_eq_natDegree ( by aesop_cat ) ] at *; norm_cast at *; linarith;
          · rw [ ZMod.intCast_zmod_eq_zero_iff_dvd ] ; intro H; replace hfg := congr_arg Polynomial.leadingCoeff hfg; simp_all +decide [ Polynomial.leadingCoeff_mul ] ;
            erw [ Polynomial.leadingCoeff, Polynomial.leadingCoeff, Polynomial.leadingCoeff, Polynomial.natDegree_add_C, Polynomial.natDegree_add_eq_left_of_natDegree_lt ] at hfg <;> norm_num at *;
            erw [ show question2_poly.coeff 46 = 1 by unfold question2_poly; norm_num [ Polynomial.coeff_X ] ] at hfg ; obtain ⟨ k, hk ⟩ := H ; replace hfg := congr_arg ( · % 3 ) hfg ; norm_num [ Int.add_emod, Int.mul_emod, hk ] at hfg;
        · rw [ Polynomial.degree_map_eq_of_leadingCoeff_ne_zero ] <;> norm_num;
          · exact le_of_not_gt fun h => right <| by rw [ Polynomial.degree_eq_natDegree <| by aesop_cat ] at *; norm_cast at *; linarith;
          · rw [ ZMod.intCast_zmod_eq_zero_iff_dvd ] ; intro H; replace hfg := congr_arg Polynomial.leadingCoeff hfg; simp_all +decide [ Polynomial.leadingCoeff_mul ] ;
            erw [ Polynomial.leadingCoeff, Polynomial.leadingCoeff, Polynomial.leadingCoeff, Polynomial.natDegree_add_C, Polynomial.natDegree_add_eq_left_of_natDegree_lt ] at hfg <;> norm_num at *;
            erw [ show question2_poly.coeff 46 = 1 by { unfold question2_poly; norm_num [ Polynomial.coeff_X ] } ] at hfg ; obtain ⟨ k, hk ⟩ := H ; replace hfg := congr_arg ( fun x => x % 3 ) hfg ; norm_num [ Int.add_emod, Int.mul_emod, hk ] at hfg;
      exact h_deg.elim ( fun h => ⟨ f, hfg ▸ dvd_mul_right _ _, h ⟩ ) fun h => ⟨ g, hfg ▸ dvd_mul_left _ _, h ⟩

/-
Any divisor of $X^n$ in $(\mathbb{Z}/3\mathbb{Z})[X]$ is of the form $c X^k$ for some non-zero constant $c$.
-/
lemma dvd_X_pow_implies_eq_C_mul_X_pow {n : ℕ} {p : Polynomial (ZMod 3)} (hp : p ∣ Polynomial.X ^ n) :
  ∃ c : ZMod 3, ∃ k : ℕ, c ≠ 0 ∧ p = Polynomial.C c * Polynomial.X ^ k := by
    rw [ dvd_prime_pow ] at hp;
    · rcases hp with ⟨ k, hk₁, hk₂ ⟩;
      rcases hk₂.symm with ⟨ u, hu ⟩;
      -- Since $u$ is a unit in the polynomial ring over $ZMod 3$, it must be a non-zero constant polynomial.
      have hu_const : ∃ c : ZMod 3, u = Polynomial.C c := by
        -- Since $u$ is a unit in the polynomial ring over $ZMod 3$, its degree must be zero.
        have hu_deg : Polynomial.degree (u : Polynomial (ZMod 3)) = 0 := by
          exact Polynomial.degree_eq_zero_of_isUnit u.isUnit;
        exact ⟨ _, Polynomial.eq_C_of_degree_eq_zero hu_deg ⟩;
      aesop;
    · exact Polynomial.prime_X

/-
If $g$ is a monic factor of $X^{46}$ in $(\mathbb{Z}/3\mathbb{Z})[X]$, then $g = X^{\deg g}$.
-/
lemma monic_factor_of_X_pow_mod_3 (g : Polynomial (ZMod 3)) (hg_monic : g.Monic) (h_dvd : g ∣ Polynomial.X ^ 46) :
  g = Polynomial.X ^ g.natDegree := by
    -- We know from `dvd_X_pow_implies_eq_C_mul_X_pow` that $g = c X^k$.
    obtain ⟨c, k, hc, rfl⟩ : ∃ c : ZMod 3, ∃ k : ℕ, c ≠ 0 ∧ g = Polynomial.C c * Polynomial.X ^ k := by
      -- Apply the lemma that states any divisor of $X^n$ in $(\mathbb{Z}/3\mathbb{Z})[X]$ is of the form $c X^k$ for some non-zero constant $c$.
      apply dvd_X_pow_implies_eq_C_mul_X_pow h_dvd;
    rw [ Polynomial.Monic.def, Polynomial.leadingCoeff_mul, Polynomial.leadingCoeff_C, Polynomial.leadingCoeff_X_pow ] at hg_monic ; aesop

/-
If $x^{46} + 69x + 2025$ is reducible, it has a factor of degree 1.
-/
lemma question2_reducible_implies_degree_one_factor_v2 (h_red : ¬ Irreducible question2_poly) :
  ∃ g : Polynomial ℤ, g ∣ question2_poly ∧ g.degree = 1 := by
    exact?

/-
The polynomial $x^{46} + 69x + 2025$ is irreducible in $\mathbb{Z}[x]$.
-/
theorem question2_true : Irreducible question2_poly := by
  by_contra h_not_irreducible;
  -- Then there exists a factor $g$ of degree 1.
  obtain ⟨g, hg⟩ : ∃ g : Polynomial ℤ, g ∣ question2_poly ∧ g.degree = 1 := question2_reducible_implies_degree_one_factor_v2 h_not_irreducible;
  -- Since $g$ is a degree 1 polynomial, it must have a root in the integers. Let's call that root $r$.
  obtain ⟨r, hr⟩ : ∃ r : ℤ, g.eval r = 0 := by
    rw [ Polynomial.eq_X_add_C_of_degree_eq_one hg.2 ] ; aesop;
    -- Since $g$ is a degree 1 polynomial, its leading coefficient is non-zero.
    have h_leading_coeff_nonzero : g.leadingCoeff ∣ 1 := by
      obtain ⟨ q, hq ⟩ := left;
      -- Since $g$ divides $f$, the leading coefficient of $g$ times the leading coefficient of $q$ (the quotient) equals the leading coefficient of $f$.
      have h_leading_coeff_div : Polynomial.leadingCoeff g * Polynomial.leadingCoeff q = Polynomial.leadingCoeff (question2_poly) := by
        rw [ hq, Polynomial.leadingCoeff_mul ];
      erw [ Polynomial.leadingCoeff, Polynomial.leadingCoeff, Polynomial.leadingCoeff, Polynomial.natDegree_add_C, Polynomial.natDegree_add_eq_left_of_natDegree_lt ] at h_leading_coeff_div <;> aesop;
      exact dvd_trans ( dvd_of_mul_right_eq _ h_leading_coeff_div ) ( by erw [ ← hq ] ; exact ⟨ 1, by norm_num [ Polynomial.coeff_one, Polynomial.coeff_X, Polynomial.coeff_C, question2_poly ] ⟩ );
    -- Since $g.leadingCoeff$ divides $1$, it must be either $1$ or $-1$.
    have h_leading_coeff_cases : g.leadingCoeff = 1 ∨ g.leadingCoeff = -1 := by
      exact Int.isUnit_iff.mp ( isUnit_of_dvd_one h_leading_coeff_nonzero );
    exact h_leading_coeff_cases.elim ( fun h => ⟨ -g.coeff 0, by rw [ h ] ; ring ⟩ ) fun h => ⟨ g.coeff 0, by rw [ h ] ; ring ⟩;
  exact absurd ( Polynomial.eval_eq_zero_of_dvd_of_eval_eq_zero hg.1 hr ) ( by exact question2_no_int_root r )

/-
It is false that there is a unique digit $d$ such that if $2^n$ and $5^n$ start with the same digit, then that digit is $d$.
-/
def first_digit (n : ℕ) : ℕ := (Nat.digits 10 n).getLastD 0

theorem question3_false : ¬ (∃! d : ℕ, d ∈ Finset.range 10 ∧ d ≠ 0 ∧
  ∀ n : ℕ, first_digit (2^n) = first_digit (5^n) → first_digit (2^n) = d) := by
    rintro ⟨ d, hd₁, hd₂ ⟩;
    have := hd₁.2.2 0 ; have := hd₁.2.2 5 ; norm_num [ first_digit ] at * ; omega

/-
For any odd prime $p$, the triple sum of Legendre symbols $\sum_{o=1}^{p-1} \sum_{r=1}^{p-1} \sum_{z=1}^{p-1} \left( \frac{orz}{p} \right)$ is divisible by $((p-1)/2)^3$.
-/
theorem question4_true (p : ℕ) [Fact p.Prime] (hp : p ≠ 2) :
  (((p - 1) / 2) ^ 3 : ℤ) ∣ ∑ o ∈ Finset.Ico 1 p, ∑ r ∈ Finset.Ico 1 p, ∑ z ∈ Finset.Ico 1 p, legendreSym p (o * r * z) := by
    -- The sum of the Legendre symbols over all non-zero elements is zero.
    have h_sum_zero : ∑ o ∈ Finset.Ico 1 p, legendreSym p o = 0 := by
      simp +decide [ legendreSym ];
      -- The sum of the quadratic characters over the multiplicative group of ZMod p is zero because for each quadratic residue, there is a corresponding non-residue, and their contributions cancel out.
      have h_sum_zero : ∑ x ∈ Finset.univ.erase 0, quadraticCharFun (ZMod p) x = 0 := by
        simp +decide [ quadraticCharFun ];
        -- Let's count the number of quadratic residues and non-residues modulo $p$.
        have h_count : (Finset.filter (fun x : ZMod p => IsSquare x) (Finset.univ : Finset (ZMod p))).card = (p + 1) / 2 ∧ (Finset.filter (fun x : ZMod p => ¬IsSquare x) (Finset.univ : Finset (ZMod p))).card = (p - 1) / 2 := by
          have h_count : (Finset.filter (fun x : ZMod p => IsSquare x) (Finset.univ : Finset (ZMod p))).card = (p + 1) / 2 := by
            rw [ Finset.card_eq_of_bijective ];
            use fun i hi => i^2;
            · aesop;
              obtain ⟨ x, rfl ⟩ := a_1;
              refine' ⟨ if x.val < ( p + 1 ) / 2 then x.val else p - x.val, _, _ ⟩ <;> aesop;
              · cases Nat.Prime.eq_two_or_odd ( Fact.out : Nat.Prime p ) <;> omega;
              · ring;
              · simp +decide [ ← sq, Nat.cast_sub ( show x.val ≤ p from x.val_lt.le ) ];
            · aesop;
            · aesop;
              rw [ sq_eq_sq_iff_eq_or_eq_neg ] at a ; aesop;
              · exact Nat.mod_eq_of_lt ( show i < p from hi.trans_le ( Nat.div_le_of_le_mul <| by linarith only [ show p > 1 from Nat.Prime.one_lt Fact.out ] ) ) ▸ Nat.mod_eq_of_lt ( show j < p from hj.trans_le ( Nat.div_le_of_le_mul <| by linarith only [ show p > 1 from Nat.Prime.one_lt Fact.out ] ) ) ▸ by simpa [ ← ZMod.natCast_eq_natCast_iff' ] using h;
              · rw [ eq_neg_iff_add_eq_zero ] at h_1;
                norm_cast at h_1;
                rw [ ZMod.natCast_eq_zero_iff ] at h_1;
                exact le_antisymm ( Nat.le_of_not_lt fun hi' => by have := Nat.le_of_dvd ( by linarith ) h_1; omega ) ( Nat.le_of_not_lt fun hj' => by have := Nat.le_of_dvd ( by linarith ) h_1; omega );
          simp_all +decide [ Finset.filter_not, Finset.card_sdiff ];
          cases Nat.Prime.odd_of_ne_two Fact.out hp ; omega;
        simp_all +decide [ Finset.sum_ite, Finset.filter_ne' ];
        simp_all +decide [ Finset.filter_erase, Finset.card_erase_of_mem ];
        omega;
      norm_num +zetaDelta at *;
      rw [ ← h_sum_zero, Finset.sum_Ico_eq_sub _ ] <;> norm_num;
      · rcases p with ( _ | _ | p ) <;> simp_all +decide [ Finset.sum_range, ZMod ];
      · -- Since $p$ is a prime number, we have $p \geq 2$.
        apply Nat.Prime.pos Fact.out;
    norm_num [ Finset.mul_sum _ _ _, Finset.sum_mul, legendreSym ] at *;
    simp_all +decide [ ← Finset.mul_sum _ _ _, ← Finset.sum_mul, quadraticCharFun_mul ]

/-
The integral $\int_{2}^{\infty} \frac{1}{x^7 - x}\, dx$ is not greater than $\frac{1}{365}$.
-/
open MeasureTheory Interval

noncomputable def question5_integral : ℝ := ∫ x in Set.Ioi 2, 1 / (x^7 - x)

theorem question5_false : ¬ (question5_integral > 1 / 365) := by
  -- Evaluate the integral
  have h_eval : ∫ x in Set.Ici (2 : ℝ), (1 : ℝ) / (x^7 - x) = (1 / 6) * Real.log ((2^6) / (2^6 - 1)) := by
    -- We'll use the fundamental theorem of calculus, identifying the antiderivative.
    -- The antiderivative of $1/(x^7 - x)$ is $(1/6) \ln((x^6 - 1)/x^6)$.
    have h_ftc : ∀ a b : ℝ, 2 ≤ a → a < b → ∫ x in a..b, (1 : ℝ) / (x ^ 7 - x) = (1 / 6) * Real.log ((b ^ 6 - 1) / b ^ 6) - (1 / 6) * Real.log ((a ^ 6 - 1) / a ^ 6) := by
      intros a b _ _; rw [ intervalIntegral.integral_eq_sub_of_hasDerivAt ] ; aesop;
      · convert HasDerivAt.mul ( hasDerivAt_const _ _ ) ( HasDerivAt.log ( HasDerivAt.div ( HasDerivAt.sub ( hasDerivAt_pow 6 x ) ( hasDerivAt_const _ _ ) ) ( hasDerivAt_pow 6 x ) _ ) _ ) using 1 <;> norm_num;
        · field_simp;
          ring;
        · cases Set.mem_uIcc.mp a_3 <;> linarith;
        · exact ⟨ by cases Set.mem_uIcc.mp a_3 <;> nlinarith [ sq_nonneg ( x^2 - 1 ) ], by cases Set.mem_uIcc.mp a_3 <;> linarith ⟩;
      · apply_rules [ ContinuousOn.intervalIntegrable ];
        -- Since $x^7 - x$ is continuous and non-zero on $[a, b]$, the function $1/(x^7 - x)$ is continuous on $[a, b]$.
        have h_cont : ContinuousOn (fun x : ℝ => x ^ 7 - x) (Set.Icc a b) ∧ ∀ x ∈ Set.Icc a b, x ^ 7 - x ≠ 0 := by
          exact ⟨ Continuous.continuousOn ( by continuity ), fun x hx => by nlinarith [ hx.1, hx.2, pow_pos ( by linarith [ hx.1 ] : 0 < x ) 2, pow_pos ( by linarith [ hx.1 ] : 0 < x ) 3, pow_pos ( by linarith [ hx.1 ] : 0 < x ) 4, pow_pos ( by linarith [ hx.1 ] : 0 < x ) 5, pow_pos ( by linarith [ hx.1 ] : 0 < x ) 6 ] ⟩;
        exact ContinuousOn.div continuousOn_const ( h_cont.1.mono <| by rw [ Set.uIcc_of_le ( by linarith ) ] ) fun x hx => h_cont.2 x <| by rwa [ Set.uIcc_of_le ( by linarith ) ] at hx;
    -- To apply the fundamental theorem of calculus, we express the improper integral as a limit of proper integrals.
    have h_lim : Filter.Tendsto (fun b => ∫ x in (2 : ℝ)..b, (1 : ℝ) / (x ^ 7 - x)) Filter.atTop (nhds (∫ x in Set.Ici (2 : ℝ), (1 : ℝ) / (x ^ 7 - x))) := by
      rw [ MeasureTheory.integral_Ici_eq_integral_Ioi ];
      apply_rules [ MeasureTheory.intervalIntegral_tendsto_integral_Ioi ];
      · -- We'll use the comparison test. Since \( \frac{1}{x^7 - x} \leq \frac{2}{x^7} \) for \( x \geq 2 \), and \( \int_{2}^{\infty} \frac{2}{x^7} \, dx \) converges.
        have h_compare : ∀ x : ℝ, 2 ≤ x → (1 : ℝ) / (x ^ 7 - x) ≤ 2 / x ^ 7 := by
          -- By cross-multiplying, we can avoid dealing with fractions and simplify the inequality.
          intro x hx
          have : x^7 ≤ 2 * (x^7 - x) := by
            nlinarith [ sq_nonneg ( x^2 - 4 ), pow_pos ( zero_lt_two.trans_le hx ) 3, pow_pos ( zero_lt_two.trans_le hx ) 4, pow_pos ( zero_lt_two.trans_le hx ) 5, pow_pos ( zero_lt_two.trans_le hx ) 6 ];
          rw [ div_le_div_iff₀ ] <;> nlinarith [ pow_pos ( zero_lt_two.trans_le hx ) 7 ];
        -- Since \( \frac{2}{x^7} \) is a p-series with \( p = 7 > 1 \), it converges.
        have h_pseries : MeasureTheory.IntegrableOn (fun x : ℝ => 2 / x ^ 7) (Set.Ioi (2 : ℝ)) MeasureTheory.MeasureSpace.volume := by
          have h_pseries : MeasureTheory.IntegrableOn (fun x : ℝ => x ^ (-7 : ℝ)) (Set.Ioi (2 : ℝ)) MeasureTheory.MeasureSpace.volume := by
            rw [ integrableOn_Ioi_rpow_iff ] <;> norm_num;
          norm_cast at * ; simpa using h_pseries.const_mul 2;
        refine' h_pseries.mono' _ _;
        · exact ContinuousOn.aestronglyMeasurable ( fun x hx => ContinuousAt.continuousWithinAt <| by exact ContinuousAt.div continuousAt_const ( ContinuousAt.sub ( continuousAt_id.pow 7 ) continuousAt_id ) <| by nlinarith [ hx.out, pow_pos ( by linarith [ hx.out ] : 0 < x ) 2, pow_pos ( by linarith [ hx.out ] : 0 < x ) 3, pow_pos ( by linarith [ hx.out ] : 0 < x ) 4, pow_pos ( by linarith [ hx.out ] : 0 < x ) 5, pow_pos ( by linarith [ hx.out ] : 0 < x ) 6 ] ) measurableSet_Ioi;
        · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioi ] with x hx using by rw [ Real.norm_of_nonneg ( one_div_nonneg.mpr ( sub_nonneg.mpr ( by nlinarith [ hx.out, pow_two_nonneg ( x^3 ), pow_two_nonneg ( x^2 - 1 ) ] ) ) ) ] ; exact h_compare x hx.out.le;
      · exact Filter.tendsto_id;
    -- We'll use the fact that $\lim_{b \to \infty} \frac{b^6 - 1}{b^6} = 1$.
    have h_lim_frac : Filter.Tendsto (fun b : ℝ => (b ^ 6 - 1) / b ^ 6) Filter.atTop (nhds 1) := by
      norm_num [ sub_div ];
      exact le_trans ( Filter.Tendsto.sub ( tendsto_const_nhds.congr' ( by filter_upwards [ Filter.eventually_ne_atTop 0 ] with x hx; aesop ) ) ( tendsto_inv_atTop_zero.comp ( by norm_num ) ) ) ( by norm_num );
    have := h_lim.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 2 ] with b hb using h_ftc 2 b le_rfl hb ) ; norm_num at * ; aesop;
    exact tendsto_nhds_unique this ( by simpa using Filter.Tendsto.sub ( tendsto_const_nhds.mul ( Filter.Tendsto.log h_lim_frac one_ne_zero ) ) tendsto_const_nhds ) ▸ by norm_num [ Real.log_div ] ; ring;
  unfold question5_integral; norm_num [ h_eval ] ; ring_nf ; norm_num;
  rw [ show ( fun x : ℝ => ( -x + x ^ 7 ) ⁻¹ ) = fun x : ℝ => ( x ^ 7 - x ) ⁻¹ by ext; ring ] ; rw [ MeasureTheory.integral_Ici_eq_integral_Ioi ] at h_eval ; norm_num at * ; linarith [ Real.log_le_sub_one_of_pos ( show 0 < 64 / 63 by norm_num ) ] ;

/-
The limit of $E(R_n) - \mathrm{Var}(R_n)$ is not less than $\frac{\pi}{2^{420/69}}$.
-/
noncomputable def question6_limit : ℝ := Real.pi ^ 2 / 6

theorem question6_false : ¬ (question6_limit < Real.pi / 2 ^ (420 / 69 : ℝ)) := by
  bound;
  -- We know that $\frac{\pi^2}{6} > \frac{\pi}{2^{420/69}}$.
  have h_ineq : Real.pi ^ 2 / 6 > Real.pi / 2 ^ (420 / 69 : ℝ) := by
    -- We can simplify the inequality to $\pi > \frac{6}{2^{420/69}}$.
    have h_simplified : Real.pi > 6 / 2 ^ (420 / 69 : ℝ) := by
      exact lt_of_le_of_lt ( div_le_one_of_le₀ ( by exact le_trans ( by norm_num ) ( Real.rpow_le_rpow_of_exponent_le ( by norm_num ) ( show ( 420 : ℝ ) / 69 ≥ 6 by norm_num ) ) ) ( by positivity ) ) ( by linarith [ Real.pi_gt_three ] );
    ring_nf at h_simplified ⊢; nlinarith [ Real.pi_gt_three ];
  refine' a.not_le _;
  exact?

/-
If four distinct real numbers are roots of $x^4 + Ax^3 + Cx^2 + Bx + 1 = 0$, then their product is 1.
-/
lemma product_of_roots_of_quartic_eq_one (x : Fin 4 → ℝ) (hx : Function.Injective x) (A B C : ℝ)
  (h_roots : ∀ i, x i ^ 4 + A * x i ^ 3 + C * x i ^ 2 + B * x i + 1 = 0) : ∏ i, x i = 1 := by
    -- Since $x_i$ are roots of $P(X)$, and they are distinct, $P(X)$ must be equal to $\prod_{i=0}^3 (X - x_i)$.
    have h_poly_eq : (Polynomial.X - Polynomial.C (x 0)) * (Polynomial.X - Polynomial.C (x 1)) * (Polynomial.X - Polynomial.C (x 2)) * (Polynomial.X - Polynomial.C (x 3)) = Polynomial.X^4 + Polynomial.C A * Polynomial.X^3 + Polynomial.C C * Polynomial.X^2 + Polynomial.C B * Polynomial.X + 1 := by
      refine' Polynomial.eq_of_degree_sub_lt_of_eval_finset_eq _ _ _;
      exact Finset.image x Finset.univ;
      · erw [ Finset.card_image_of_injective _ hx ] ; erw [ Polynomial.degree_lt_iff_coeff_zero ] ; aesop;
        · norm_num [ mul_sub, Polynomial.coeff_one, Polynomial.coeff_X ];
        · rcases m with ( _ | _ | _ | _ | _ | m ) <;> simp_all +decide [ mul_sub, Polynomial.coeff_eq_zero_of_natDegree_lt ];
      · -- Since $x$ is injective, for any $x_1$ in the image of $x$, there exists an $i$ such that $x_1 = x i$.
        intro x_1 hx_1
        obtain ⟨i, hi⟩ : ∃ i, x_1 = x i := by
          aesop;
        fin_cases i <;> simp_all +decide [ Fin.prod_univ_four ];
    replace h_poly_eq := congr_arg ( Polynomial.eval 0 ) h_poly_eq ; simp_all +decide [ Fin.prod_univ_four ]

/-
If $x$ satisfies $x^2 + (1/x)^2 + Ax + B/x + C = 0$ and $x \ne 0$, then $x^4 + Ax^3 + Cx^2 + Bx + 1 = 0$.
-/
lemma circle_eq_implies_quartic (x A B C : ℝ) (hx : x ≠ 0)
  (h : x^2 + (1/x)^2 + A*x + B*(1/x) + C = 0) :
  x^4 + A*x^3 + C*x^2 + B*x + 1 = 0 := by
    field_simp at h;
    linarith

/-
There exist unique bijections $f, g, h$ on $\mathbb{N}$ such that $f(n)^3 + g(n)^3 + h(n)^3 = 3 n g(n) h(n)$ for all $n$.
-/
def question9_statement : Prop :=
  ∃! (t : (ℕ → ℕ) × (ℕ → ℕ) × (ℕ → ℕ)),
    let f := t.1
    let g := t.2.1
    let h := t.2.2
    Function.Bijective f ∧ Function.Bijective g ∧ Function.Bijective h ∧
    ∀ n, f n ^ 3 + g n ^ 3 + h n ^ 3 = 3 * n * g n * h n

theorem question9_true : question9_statement := by
  fconstructor;
  exact ( id, id, id );
  -- Now, we need to show that if there are other bijections f, g, h satisfying the equation, they must be the identity function.
  have h_unique : ∀ f g h : ℕ → ℕ, Function.Bijective f → Function.Bijective g → Function.Bijective h → (∀ n, f n ^ 3 + g n ^ 3 + h n ^ 3 = 3 * n * g n * h n) → f = id ∧ g = id ∧ h = id := by
    intro f g h hf hg hh h_eq
    have h_f_id : f = id := by
      -- By the properties of the equation and the fact that $f$, $g$, and $h$ are bijections, we can deduce that $f(n) \leq n$ for all $n$.
      have h_f_le_n : ∀ n, f n ≤ n := by
        intro n;
        by_cases hgn : g n > 0;
        · by_cases hhn : h n > 0;
          · nlinarith [ sq_nonneg ( f n - g n : ℤ ), sq_nonneg ( g n - h n : ℤ ), sq_nonneg ( h n - f n : ℤ ), h_eq n, mul_pos hgn hhn ];
          · have := h_eq n; aesop;
        · have := h_eq n; aesop;
      funext n; induction' n using Nat.strong_induction_on with n ih; aesop; (
      by_contra h_contra;
      -- Since $f$ is a bijection and $f(n) \neq n$, it must be that $f(n) < n$.
      have h_f_lt_n : f n < n := by
        exact lt_of_le_of_ne ( h_f_le_n n ) h_contra;
      have := hf.injective ( by aesop : f ( f n ) = f n ) ; aesop;);
    have h_g_id : g = id := by
      ext n; specialize h_eq n; aesop;
      by_contra h_contra;
      exact h_contra ( by nlinarith [ sq_nonneg ( n - g n : ℤ ), sq_nonneg ( n - h n : ℤ ), sq_nonneg ( g n - h n : ℤ ) ] )
    have h_h_id : h = id := by
      funext n; specialize h_eq n; aesop;
      nlinarith [ sq_nonneg ( h n - n : ℤ ), sq_nonneg ( h n + n : ℤ ) ]
    exact ⟨h_f_id, h_g_id, h_h_id⟩;
  simp +zetaDelta at *;
  exact ⟨ ⟨ Function.bijective_id, fun n => by ring ⟩, h_unique ⟩

/-
Sorry, Aristotle was unable to complete the task in time.
-/
/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
-/

/-
For each σ ∈ S_n, let Orb(σ) be the number of cycles of σ.
-/
def Orb {n : ℕ} (σ : Equiv.Perm (Fin n)) : ℕ :=
  σ.cycleType.card + (n - σ.cycleType.sum)

/-
Define the n-th harmonic number H_n.
-/
def H (n : ℕ) : ℚ := ∑ i ∈ Finset.range n, (1 : ℚ) / (i + 1)

/-
The 69th harmonic number is greater than 4.
-/
lemma H_69_gt_4 : H 69 > 4 := by
  rw [H]
  norm_num

/-
Orb(σ) is the sum over k of the number of cycles of length k.
-/
def count_cycles_of_length {n : ℕ} (k : ℕ) (σ : Equiv.Perm (Fin n)) : ℕ :=
  if k = 1 then Fintype.card {x // σ x = x}
  else (σ.cycleType.filter (· = k)).card

lemma orb_eq_sum_count {n : ℕ} (σ : Equiv.Perm (Fin n)) :
  Orb σ = ∑ k ∈ Finset.range (n + 1), count_cycles_of_length k σ := by
  unfold Orb count_cycles_of_length;
  have h_orb : σ.cycleType.card = ∑ k ∈ Finset.Ico 1 (n + 1), (Multiset.filter (fun x => x = k) σ.cycleType).card := by
    have h_orb : σ.cycleType.card = ∑ k ∈ σ.cycleType.toFinset, (Multiset.filter (fun x => x = k) σ.cycleType).card := by
      simp +decide [ Multiset.filter_eq' ];
    rw [ h_orb, Finset.sum_subset ];
    · intro k hk;
      aesop;
      · exact Nat.pos_of_ne_zero ( by intro t; have := Equiv.Perm.mem_cycleType_iff.mp hk; aesop );
      · have := σ.sum_cycleType;
        exact Nat.lt_succ_of_le ( le_trans ( Multiset.le_sum_of_mem hk ) ( this.le.trans ( le_trans ( Finset.card_le_univ _ ) ( by norm_num ) ) ) );
    · simp +contextual [ Multiset.filter_eq' ];
  have h_sum_fixed_points : ∑ x : Fin n, (if σ x = x then 1 else 0) = n - σ.cycleType.sum := by
    have := σ.sum_cycleType; aesop;
    rw [ show ( Finset.univ.filter fun x => σ x = x ) = Finset.univ \ σ.support from Finset.ext fun x => by simp +decide [ Equiv.Perm.mem_support ], Finset.card_sdiff ] ; aesop;
  simp_all +decide [ Finset.sum_ite, Fintype.card_subtype ];
  rcases n with ( _ | _ | n ) <;> simp_all +decide [ Finset.sum_Ico_eq_sum_range ];
  · fin_cases σ ; simp +decide [ Finset.sum_filter ];
  · rw [ add_comm, Finset.sum_filter ];
    simp +arith +decide [ Finset.sum_range_succ' ];
    rw [ Multiset.filter_eq', Multiset.filter_eq' ] ; aesop;
    rw [ Multiset.count_eq_zero.mpr, Multiset.count_eq_zero.mpr ] <;> aesop;
    · rw [ Equiv.Perm.mem_cycleType_iff ] at a ; aesop;
    · rw [ Equiv.Perm.mem_cycleType_iff ] at a;
      obtain ⟨ c, τ, rfl, h₁, h₂, h₃ ⟩ := a; have := h₂.orderOf; simp_all +decide [ Equiv.Perm.Disjoint ] ;

/-
The sum over all permutations of the number of cycles of length k is n! / k.
-/
lemma sum_count_cycles (n k : ℕ) (hk : 1 ≤ k) (hkn : k ≤ n) :
  (∑ σ : Equiv.Perm (Fin n), (count_cycles_of_length k σ : ℚ)) = (Nat.factorial n : ℚ) / k := by
  cases eq_or_lt_of_le hk <;> unfold count_cycles_of_length <;> aesop;
  · simp +decide only [Fintype.card_subtype];
    -- For each element $x \in \{0, 1, ..., n-1\}$, the number of permutations that fix $x$ is $(n-1)!$.
    have h_fix : ∀ x : Fin n, ∑ σ : Equiv.Perm (Fin n), (if σ x = x then 1 else 0) = (Nat.factorial (n - 1) : ℚ) := by
      intro x;
      have h_fixed_point : Finset.card (Finset.filter (fun σ : Equiv.Perm (Fin n) => σ x = x) Finset.univ) = Finset.card (Finset.univ : Finset (Equiv.Perm {y : Fin n // y ≠ x})) := by
        refine' Finset.card_bij ( fun σ _ => Equiv.Perm.subtypePerm σ ( by aesop ) ) _ _ _ <;> aesop;
        · ext y; by_cases hy : y = x <;> simp_all +decide [ Equiv.Perm.ext_iff ] ;
          grind +ring;
        · refine' ⟨ Equiv.Perm.extendDomain b ( Equiv.refl _ ), _, _ ⟩ <;> aesop;
          exact?;
          ext y; simp +decide [ Equiv.Perm.extendDomain ] ;
      simp_all +decide [ Finset.card_univ, Fintype.card_perm ];
    -- By Fubini's theorem, we can interchange the order of summation.
    have h_fubini : ∑ x : Fin n, ∑ σ : Equiv.Perm (Fin n), (if σ x = x then 1 else 0) = ∑ σ : Equiv.Perm (Fin n), ∑ x : Fin n, (if σ x = x then 1 else 0) := by
      exact Finset.sum_comm;
    cases n <;> simp_all +decide [ Nat.factorial_succ ];
  · -- Let $c$ be a cycle of length $k$ in $S_n$. The number of permutations containing $c$ is $(n-k)!$.
    have h_cycle_count : ∀ c : Equiv.Perm (Fin n), c.cycleType = {k} → ∑ σ : Equiv.Perm (Fin n), (if c ∈ σ.cycleFactorsFinset then 1 else 0) = (Nat.factorial (n - k) : ℚ) := by
      intro c hc
      have h_cycle_count : Finset.card (Finset.filter (fun σ : Equiv.Perm (Fin n) => c ∈ σ.cycleFactorsFinset) Finset.univ) = (Nat.factorial (n - k) : ℚ) := by
        have h_cycle_count : Finset.card (Finset.filter (fun σ : Equiv.Perm (Fin n) => c ∈ σ.cycleFactorsFinset) Finset.univ) = Finset.card (Finset.image (fun σ : Equiv.Perm (Fin n) => c * σ) (Finset.filter (fun σ : Equiv.Perm (Fin n) => ∀ x ∈ c.support, σ x = x) Finset.univ)) := by
          congr with σ ; aesop;
          · have := Equiv.Perm.mem_cycleFactorsFinset_iff.mp a; aesop;
            rw [ ← right x a_1, Equiv.Perm.inv_apply_self ];
          · rw [ Equiv.Perm.mem_cycleFactorsFinset_iff ];
            aesop;
            · have := Equiv.Perm.card_cycleType_eq_one.mp ( by aesop : Multiset.card c.cycleType = 1 ) ; aesop;
            · have := a a_1 a_2; have := Equiv.Perm.inv_eq_iff_eq.mp this; aesop;
        rw [ h_cycle_count, Finset.card_image_of_injective _ fun x y hxy => by simpa using hxy ];
        -- The set of permutations fixing the support of $c$ is in bijection with the set of permutations of the remaining $n-k$ elements.
        have h_bij : Finset.filter (fun σ : Equiv.Perm (Fin n) => ∀ x ∈ c.support, σ x = x) Finset.univ = Finset.image (fun σ : Equiv.Perm {x : Fin n | x ∉ c.support} => Equiv.Perm.ofSubtype σ) (Finset.univ : Finset (Equiv.Perm {x : Fin n | x ∉ c.support})) := by
          ext σ; simp [Equiv.Perm.ofSubtype];
          constructor;
          · intro hσ;
            -- Since σ fixes the support of c, we can restrict σ to the complement of the support of c, which is a permutation of that complement.
            obtain ⟨a, ha⟩ : ∃ a : Equiv.Perm {x : Fin n | x ∉ c.support}, ∀ x : {x : Fin n | x ∉ c.support}, a x = σ x := by
              have h_restrict : ∀ x : {x : Fin n | x ∉ c.support}, σ x ∈ {x : Fin n | x ∉ c.support} := by
                intro x hx; specialize hσ ( σ x ) ; aesop;
              have h_restrict : Function.Bijective (fun x : {x : Fin n | x ∉ c.support} => ⟨σ x, h_restrict x⟩ : {x : Fin n | x ∉ c.support} → {x : Fin n | x ∉ c.support}) := by
                have h_restrict : Function.Injective (fun x : {x : Fin n | x ∉ c.support} => ⟨σ x, h_restrict x⟩ : {x : Fin n | x ∉ c.support} → {x : Fin n | x ∉ c.support}) := by
                  intro x y; aesop;
                exact ⟨ h_restrict, Finite.injective_iff_surjective.mp h_restrict ⟩;
              exact ⟨ Equiv.ofBijective _ h_restrict, fun x => rfl ⟩;
            use a;
            ext x; by_cases hx : x ∈ c.support <;> simp_all +decide [ Equiv.Perm.extendDomain ] ;
          · rintro ⟨ a, rfl ⟩ x hx; simp +decide [ Equiv.Perm.extendDomain ] ; aesop;
        rw [ h_bij, Finset.card_image_of_injective ];
        · simp +decide [ Finset.card_univ, Fintype.card_perm ];
          have := Equiv.Perm.sum_cycleType c; aesop;
          rw [ Fintype.card_subtype ];
          rw [ show ( Finset.univ.filter fun x => c x = x ) = Finset.univ \ c.support by ext; aesop, Finset.card_sdiff ] ; aesop;
        · intro σ τ hστ; ext x; replace hστ := Equiv.congr_fun hστ x; aesop;
      aesop;
    -- The number of cycles of length $k$ in $S_n$ is $\binom{n}{k} (k-1)!$.
    have h_cycle_count : (Finset.filter (fun c : Equiv.Perm (Fin n) => c.cycleType = {k}) Finset.univ).card = (Nat.choose n k * Nat.factorial (k - 1) : ℚ) := by
      have := Equiv.Perm.card_of_cycleType ( Fin n ) [ k ] ; aesop;
      · rw [ Nat.cast_div ];
        · rw [ Nat.cast_choose ];
          · field_simp;
            cases k <;> norm_num [ Nat.factorial ] at * ; linarith;
          · bound;
        · rw [ ← Nat.choose_mul_factorial_mul_factorial hkn ];
          exact ⟨ Nat.choose n k * Nat.factorial ( k - 1 ), by cases k <;> simp_all +decide [ Nat.factorial_succ, mul_comm, mul_assoc, mul_left_comm ] ⟩;
        · positivity;
      · grind +ring;
    -- Therefore, the sum over all permutations of the number of cycles of length $k$ is $\binom{n}{k} (k-1)! \cdot (n-k)!$.
    have h_sum_cycle_count : ∑ σ : Equiv.Perm (Fin n), (Multiset.filter (fun x => x = k) σ.cycleType).card = (Nat.choose n k * Nat.factorial (k - 1) : ℚ) * (Nat.factorial (n - k) : ℚ) := by
      -- By definition of cycle type, the number of cycles of length $k$ in $\sigma$ is equal to the number of elements in the set $\{c \in \text{cycleFactorsFinset}(\sigma) \mid c.cycleType = \{k\}\}$.
      have h_cycle_count_eq : ∀ σ : Equiv.Perm (Fin n), (Multiset.filter (fun x => x = k) σ.cycleType).card = ∑ c ∈ Finset.filter (fun c : Equiv.Perm (Fin n) => c.cycleType = {k}) Finset.univ, (if c ∈ σ.cycleFactorsFinset then 1 else 0) := by
        intro σ
        have h_cycle_count_eq : (Multiset.filter (fun x => x = k) σ.cycleType).card = Finset.card (Finset.filter (fun c : Equiv.Perm (Fin n) => c.cycleType = {k}) (σ.cycleFactorsFinset)) := by
          have h_cycle_count_eq : σ.cycleType = Multiset.map (fun c => c.cycleType.sum) (σ.cycleFactorsFinset.val) := by
            rw [ Equiv.Perm.cycleType_def ];
            congr! 2;
            aesop;
            have := Equiv.Perm.sum_cycleType x; aesop;
          rw [ h_cycle_count_eq, Multiset.filter_map ];
          simp +decide [ Function.comp, Multiset.filter_eq' ];
          congr with x ; aesop;
          by_cases hx : x.cycleType = { k } <;> simp_all +decide [ Multiset.count_filter ];
          contrapose! hx; aesop;
          have := Equiv.Perm.mem_cycleFactorsFinset_iff.mp right; aesop;
          have := left.cycleType; aesop;
        simp_all +decide [ Finset.sum_ite ];
        exact congr_arg Finset.card ( by ext; aesop );
      push_cast [ h_cycle_count_eq ];
      rw [ Finset.sum_comm ];
      rw [ Finset.sum_congr rfl fun x hx => by aesop ] ; aesop;
    rw [ eq_div_iff ] <;> norm_cast at * <;> aesop;
    rw [ ← Nat.choose_mul_factorial_mul_factorial hkn ];
    cases k <;> simp_all +decide [ Nat.factorial_succ, mul_comm, mul_assoc, mul_left_comm ]

/-
The sum of Orb over all permutations is n! * H n.
-/
lemma sum_orb_eq (n : ℕ) : (∑ σ : Equiv.Perm (Fin n), (Orb σ : ℚ)) = (Nat.factorial n : ℚ) * H n := by
  -- We can rewrite the sum as $\sum_{k=1}^n \sum_{\sigma \in S_n} \text{count\_cycles\_of\_length } k \sigma$.
  have h_sum_count_cycles : (∑ σ : Equiv.Perm (Fin n), (Orb σ : ℚ)) = ∑ k ∈ Finset.Ico 1 (n + 1), (∑ σ : Equiv.Perm (Fin n), (count_cycles_of_length k σ : ℚ)) := by
    -- We can rewrite the sum as $\sum_{k=1}^n \sum_{\sigma \in S_n} \text{count\_cycles\_of\_length } k \sigma$ by interchanging the order of summation.
    have h_sum_count_cycles : (∑ σ : Equiv.Perm (Fin n), (Orb σ : ℚ)) = ∑ σ : Equiv.Perm (Fin n), (∑ k ∈ Finset.Ico 1 (n + 1), (count_cycles_of_length k σ : ℚ)) := by
      congr;
      ext σ;
      -- Since the sum from 0 to n is equal to the sum from 1 to n, we can rewrite the sum in orb_eq_sum_count to start from 1 instead of 0.
      have h_sum_shift : ∑ k ∈ Finset.range (n + 1), (count_cycles_of_length k σ : ℚ) = ∑ k ∈ Finset.Ico 1 (n + 1), (count_cycles_of_length k σ : ℚ) := by
        rw [ Finset.sum_Ico_eq_sub _ ] <;> norm_num [ Finset.sum_range_succ' ];
        unfold count_cycles_of_length; aesop;
        rw [ Equiv.Perm.mem_cycleType_iff ] at a_1 ; aesop;
      convert h_sum_shift using 1;
      exact_mod_cast orb_eq_sum_count σ;
    rw [ h_sum_count_cycles, Finset.sum_comm ];
  rw [ h_sum_count_cycles ];
  norm_num [ H ];
  rw [ Finset.mul_sum _ _ _ ];
  rw [ Finset.sum_congr rfl fun i hi => sum_count_cycles n i ( Finset.mem_Ico.mp hi |>.1 ) ( by linarith [ Finset.mem_Ico.mp hi |>.2 ] ) ] ; norm_num [ Finset.sum_Ico_eq_sum_range ];
  exact Finset.sum_congr rfl fun _ _ => by ring;

/-
The average number of cycles in a permutation of length 69 is H_69, which is greater than 4.
-/
theorem bernoulli_2025_q1 :
  ¬ ((∑ σ : Equiv.Perm (Fin 69), (Orb σ : ℚ)) / (Nat.factorial 69) < 4) := by
  -- Apply the sum_orb_eq lemma to rewrite the sum.
  have h_sum : (∑ σ : Equiv.Perm (Fin 69), (Orb σ : ℚ)) = (Nat.factorial 69 : ℚ) * H 69 := by
    exact?;
  -- Substitute h_sum into the goal and simplify the division.
  rw [h_sum]
  field_simp;
  native_decide +revert

/-
T/F: There does not exist B such that dim({BAB}) = 2025.
Answer: False.
-/
theorem bernoulli_2025_q2 :
  ¬ (∀ B : Matrix (Fin 69) (Fin 69) ℝ, Module.finrank ℝ (LinearMap.range (LinearMap.mulLeftRight ℝ (B, B))) ≠ 2025) := by
  push_neg;
  -- Let's choose the matrix $B$ to be a diagonal matrix with 45 ones on the diagonal and 24 zeros.
  let B : Matrix (Fin 69) (Fin 69) ℝ := Matrix.diagonal (fun i => if i.val < 45 then 1 else 0);
  -- The range of the linear map A → BAB is isomorphic to the space of 45x45 matrices, which has dimension 2025.
  have h_iso : LinearMap.range (LinearMap.mulLeftRight ℝ (B, B)) ≃ₗ[ℝ] Matrix (Fin 45) (Fin 45) ℝ := by
    -- Define the linear map that takes a matrix in the range and returns the 45x45 submatrix.
    let f : ↥(LinearMap.range (LinearMap.mulLeftRight ℝ (B, B))) → Matrix (Fin 45) (Fin 45) ℝ := fun M => fun i j => M.val (Fin.castLE (by decide) i) (Fin.castLE (by decide) j);
    -- To prove the isomorphism, we show that $f$ is bijective.
    have h_f_bijective : Function.Bijective f := by
      constructor <;> intro M <;> aesop;
      · ext i j; by_cases hi : ( i : ℕ ) < 45 <;> by_cases hj : ( j : ℕ ) < 45 <;> simp +decide [ *, Matrix.mul_apply ] ;
        · simp_all +decide [ Finset.sum_ite, Matrix.diagonal ];
          convert congr_fun ( congr_fun a ⟨ i, hi ⟩ ) ⟨ j, hj ⟩ using 1;
        · simp +decide [ Matrix.diagonal, Finset.sum_ite, hi, hj ];
        · simp_all +decide [ Matrix.diagonal ];
          split_ifs <;> linarith;
        · simp_all +decide [ Finset.sum_eq_zero, Matrix.diagonal ];
      · use fun i j => if hi : i.val < 45 ∧ j.val < 45 then M ⟨ i.val, hi.1 ⟩ ⟨ j.val, hi.2 ⟩ else 0;
        ext i j; aesop;
    refine' { Equiv.ofBijective f h_f_bijective with .. } ; aesop_cat;
    aesop;
  exact ⟨ B, by simpa [ Module.finrank ] using h_iso.finrank_eq ⟩

/-
Checking for Complex.normSq and other constants.
-/
#check Complex.normSq
#check Complex.I
#check Complex.exp
#check Real.pi

/-
T/F: There exist integers a, b, c such that |ζ^a + ζ^b + ζ^c + 1| = sqrt(3).
Answer: True (we suspect).
-/
noncomputable def ζ : ℂ := Complex.exp (2 * Real.pi * Complex.I / 13)

theorem bernoulli_2025_q3 :
  ∃ a b c : ℤ, Complex.normSq (ζ^a + ζ^b + ζ^c + 1) = 3 := by
  by_contra h;
  -- Consider the specific case when $a = 1$, $b = 3$, and $c = 9$.
  set a : ℤ := 1
  set b : ℤ := 3
  set c : ℤ := 9;
  -- Compute the sum ζ + ζ^3 + ζ^9 + 1 and its conjugate.
  set S : ℂ := ζ ^ a + ζ ^ b + ζ ^ c + 1
  set S_conj : ℂ := ζ ^ (-a : ℤ) + ζ ^ (-b : ℤ) + ζ ^ (-c : ℤ) + 1;
  -- Compute the product $S \cdot S_conj$.
  have h_prod : S * S_conj = 3 := by
    -- Compute the sum of the roots of unity.
    have h_sum : ∑ k ∈ Finset.range 13, ζ ^ k = 0 := by
      rw [ geom_sum_eq ] <;> norm_num [ ζ, Complex.exp_ne_zero ];
      · exact Or.inl ( by rw [ ← Complex.exp_nat_mul, mul_comm ] ; norm_num );
      · exact ne_of_apply_ne Complex.im ( by norm_num [ Complex.exp_im ] ; exact ne_of_gt ( Real.sin_pos_of_pos_of_lt_pi ( by positivity ) ( by linarith [ Real.pi_pos ] ) ) );
    norm_num [ Finset.sum_range_succ ] at h_sum;
    simp +zetaDelta at *;
    field_simp;
    rw [ div_add_one, mul_div_assoc' ];
    · grind;
    · exact pow_ne_zero _ ( Complex.exp_ne_zero _ );
  refine' h ⟨ a, b, c, _ ⟩;
  convert congr_arg Complex.re h_prod using 1;
  simp +zetaDelta at *;
  norm_num [ Complex.normSq, Complex.exp_re, Complex.exp_im, ← Complex.exp_nat_mul ] ; ring;
  norm_num [ show ζ.re ^ 2 + ζ.im ^ 2 = 1 by norm_num [ ζ ] ; ring_nf; norm_num [ Complex.exp_re, Complex.exp_im ] ] ; ring

/-
Checking integral notation and sqrt.
-/
#check ∫ x in (0:ℝ)..1, x
#check Real.sqrt

/-
Checking for Irrational and IntervalIntegrable.
-/
#check Irrational
#check IntervalIntegrable

/-
T/F: The integral is irrational.
Answer: False (it is 0 because it diverges).
-/
noncomputable def bernoulli_2025_q4_integral : ℝ :=
  ∫ x in (0:ℝ)..1, (Real.sqrt (1 + 8*x - 8*x^3) - Real.sqrt x / (4 - x + 1) - 1 / (4*x))

theorem bernoulli_2025_q4 :
  ¬ Irrational bernoulli_2025_q4_integral := by
  unfold bernoulli_2025_q4_integral;
  rw [ intervalIntegral.integral_undef ];
  · -- Since 0 is a rational number, it is not irrational.
    simp [Irrational];
  · -- The term $1/(4x)$ is not integrable over $[0, 1]$ because it has a non-integrable singularity at $x=0$.
    have h_not_integrable : ¬ IntervalIntegrable (fun x : ℝ => 1 / (4 * x)) MeasureTheory.MeasureSpace.volume 0 1 := by
      exact fun h => absurd ( h.mul_const 4 ) ( by simp );
    contrapose! h_not_integrable;
    convert h_not_integrable.neg.add ( show IntervalIntegrable ( fun x : ℝ => Real.sqrt ( 1 + 8 * x - 8 * x ^ 3 ) - Real.sqrt x / ( 4 - x + 1 ) ) MeasureTheory.MeasureSpace.volume 0 1 from ?_ ) using 1;
    · aesop;
    · exact ContinuousOn.intervalIntegrable ( by exact ContinuousOn.sub ( ContinuousOn.sqrt <| ContinuousOn.sub ( continuousOn_const.add <| continuousOn_const.mul continuousOn_id ) <| continuousOn_const.mul <| continuousOn_pow 3 ) <| ContinuousOn.div ( Real.continuous_sqrt.continuousOn ) ( ContinuousOn.add ( continuousOn_const.sub continuousOn_id ) continuousOn_const ) fun x hx => by linarith [ Set.mem_Icc.mp <| by simpa using hx ] )

/-
A positive integer is a Gian's integer if it is of the form a^4 + b^3 for some positive integers a,b.
-/
def IsGianInteger (x : ℕ) : Prop :=
  ∃ a b : ℕ, a > 0 ∧ b > 0 ∧ x = a^4 + b^3

/-
Check for clusters of Gian's integers for n=3 (length 27, count 4).
-/
def isGian_computable (x : ℕ) : Bool :=
  (List.range (x + 1)).any fun a =>
    if a == 0 then false else
    let rem := x - a^4
    if rem == 0 then false else
    let b := Nat.sqrt rem -- approximation, need to check if b^3 = rem or (b-1)^3 or (b+1)^3?
    -- Actually, just iterate b. Since b^3 < x, b < x^(1/3).
    -- For x=1000, b < 10.
    (List.range (x + 1)).any fun b =>
      if b == 0 then false else
      a^4 + b^3 == x

def countGian_computable (m n : ℕ) : ℕ :=
  (List.range (n^3)).foldl (fun acc k => if isGian_computable (m + 1 + k) then acc + 1 else acc) 0

#eval (List.range 200).filter (fun m => countGian_computable m 3 == 4)

/-
The number of Gian integers less than N is at most roughly N^(7/12).
-/
lemma gian_card_bound (N : ℕ) :
  (Finset.filter IsGianInteger (Finset.range N)).card ≤ (Nat.sqrt (Nat.sqrt N) + 1) * (Nat.floor (Real.rpow N (1/3)) + 1) := by
  -- The number of possible values for $a$ is at most $\sqrt[4]{N} + 1$, and the number of possible values for $b$ is at most $\sqrt[3]{N} + 1$.
  have h_bounds : ∀ a b : ℕ, a > 0 → b > 0 → a^4 + b^3 < N → a ≤ Nat.sqrt (Nat.sqrt N) ∧ b ≤ Nat.floor (Real.rpow N (1/3)) := by
    aesop;
    · rw [ Nat.le_sqrt, Nat.le_sqrt ] ; nlinarith [ pow_pos a_1 2, pow_pos a_1 3, pow_pos a_2 2, pow_pos a_2 3 ];
    · refine Nat.le_floor ?_;
      -- Since $a^4$ is positive, we have $b^3 < N$.
      have h_b3_lt_N : (b : ℝ) ^ 3 < N := by
        norm_cast ; linarith [ pow_pos a_1 4 ];
      exact le_trans ( by rw [ ← Real.rpow_natCast, ← Real.rpow_mul ( by positivity ) ] ; norm_num ) ( Real.rpow_le_rpow ( by positivity ) h_b3_lt_N.le ( by positivity ) );
  -- The set of Gian integers less than N is a subset of the set of numbers of the form a^4 + b^3 where a and b are within the given bounds.
  have h_subset : Finset.filter IsGianInteger (Finset.range N) ⊆ Finset.image (fun p : ℕ × ℕ => p.1^4 + p.2^3) (Finset.product (Finset.Icc 1 (Nat.sqrt (Nat.sqrt N))) (Finset.Icc 1 (Nat.floor (Real.rpow N (1/3))))) := by
    exact fun x hx => by rcases Finset.mem_filter.mp hx with ⟨ hx₁, ⟨ a, b, ha, hb, rfl ⟩ ⟩ ; exact Finset.mem_image.mpr ⟨ ( a, b ), Finset.mem_product.mpr ⟨ Finset.mem_Icc.mpr ⟨ ha, h_bounds a b ha hb ( by linarith [ Finset.mem_range.mp hx₁ ] ) |>.1 ⟩, Finset.mem_Icc.mpr ⟨ hb, h_bounds a b ha hb ( by linarith [ Finset.mem_range.mp hx₁ ] ) |>.2 ⟩ ⟩, rfl ⟩ ;
  exact le_trans ( Finset.card_le_card h_subset ) ( Finset.card_image_le.trans <| by erw [ Finset.card_product ] ; norm_num ; nlinarith )

/-
The difference between (b+n)^3 and b^3 is greater than n^3.
-/
lemma cubes_span_gt (b n : ℕ) (hb : b > 0) (hn : n > 0) : (b + n)^3 - b^3 > n^3 := by
  exact lt_tsub_iff_left.mpr ( by nlinarith [ mul_pos hb hn ] )


end bt_2025