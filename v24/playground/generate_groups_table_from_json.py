#!/usr/bin/env python3
"""
Generate an HTML table of small groups from collected statistics.
Reads from group_stats.json (generated by collect_group_stats.py).
Includes both implemented and unimplemented groups from TSV file.
"""

import json
import csv
import re
from collections import defaultdict
from pathlib import Path
from parse_group_label import parse_group_label


def load_stats_from_json(json_file="group_stats.json"):
    """Load group statistics from JSON file."""
    with open(json_file, 'r') as f:
        data = json.load(f)

    # Convert string keys back to tuples
    groups = {}
    for key, value in data['groups'].items():
        order, gap_id = map(int, key.split(','))
        groups[(order, gap_id)] = value

    group_info = {}
    for key, value in data['group_info'].items():
        order, gap_id = map(int, key.split(','))
        group_info[(order, gap_id)] = value

    return groups, group_info


def load_all_groups_from_tsv(tsv_file="group_names.tsv"):
    """
    Load all groups from TSV file with their labels.
    Returns dict: {(order, gap_id): {'label': label, 'implemented': bool}}
    """
    all_groups = {}

    with open(tsv_file, 'r') as f:
        reader = csv.reader(f, delimiter='\t')
        for row in reader:
            if len(row) < 2:
                continue

            label = row[0]
            gap_id_and_alts = row[1]

            # Split the second column by whitespace to separate GAP ID from alternative names
            parts = gap_id_and_alts.split()
            gap_id_str = parts[0]

            # Parse gap_id as "order,id"
            order, gap_id = map(int, gap_id_str.split(','))

            # Collect alternative names
            alt_labels = []
            if len(parts) > 1:
                alt_labels.extend(parts[1:])
            if len(row) >= 3:
                for alt_name in row[2:]:
                    alt_name = alt_name.strip()
                    if alt_name:
                        alt_labels.append(alt_name)

            # Check if this group is implementable (try primary, then alternatives)
            lean_type = parse_group_label(label, order)
            if not lean_type:
                for alt_label in alt_labels:
                    lean_type = parse_group_label(alt_label, order)
                    if lean_type:
                        break
            implemented = lean_type is not None

            all_groups[(order, gap_id)] = {
                'label': label,
                'implemented': implemented
            }

    return all_groups


def format_group_name_html(name):
    """Convert Lean group name to HTML with proper formatting."""
    if not name:
        return ""

    # Handle cyclic groups: Z8 -> ℤ₈
    if name.startswith('Z') and name[1:].isdigit():
        n = name[1:]
        subscript = ''.join(['₀₁₂₃₄₅₆₇₈₉'[int(d)] for d in n])
        return f"ℤ{subscript}"

    # Handle dihedral groups: Dih5 -> D₅
    if name.startswith('Dih') and name[3:].isdigit():
        n = name[3:]
        subscript = ''.join(['₀₁₂₃₄₅₆₇₈₉'[int(d)] for d in n])
        return f"D{subscript}"

    # Handle symmetric groups: S3, S4 -> S₃, S₄
    if name.startswith('S') and len(name) <= 3 and name[1:].isdigit():
        n = name[1:]
        subscript = ''.join(['₀₁₂₃₄₅₆₇₈₉'[int(d)] for d in n])
        return f"S{subscript}"

    # Handle quaternion group: Q -> Q₈
    if name == 'Q':
        return "Q₈"

    # Handle elementary abelian groups: E8 -> ℤ₂³, E9 -> ℤ₃²
    if name.startswith('E') and name[1:].isdigit():
        n = int(name[1:])
        # E8 = Z2^3, E9 = Z3^2, E27 = Z3^3, etc.
        if n == 4:
            return "ℤ₂²"
        elif n == 8:
            return "ℤ₂³"
        elif n == 9:
            return "ℤ₃²"
        elif n == 16:
            return "ℤ₂⁴"
        elif n == 25:
            return "ℤ₅²"
        elif n == 27:
            return "ℤ₃³"
        elif n == 32:
            return "ℤ₂⁵"

    # Handle direct products: C2_C6 -> ℤ₂ × ℤ₆
    if '_' in name and name.replace('_', '').replace('C', '').isdigit():
        parts = name.split('_')
        formatted_parts = []
        for part in parts:
            if part.startswith('C') and part[1:].isdigit():
                n = part[1:]
                subscript = ''.join(['₀₁₂₃₄₅₆₇₈₉'[int(d)] for d in n])
                formatted_parts.append(f"ℤ{subscript}")
        if formatted_parts:
            return ' × '.join(formatted_parts)

    # Handle names like Gap_8_2 - parse from Lean definition would be better but this is a fallback
    if name.startswith('Gap_'):
        return name  # Keep as-is, will show Gap(order, id) in final output

    # Handle alternating groups: A4 -> A₄, A5 -> A₅
    if name.startswith('A') and len(name) <= 3 and name[1:].isdigit():
        n = name[1:]
        subscript = ''.join(['₀₁₂₃₄₅₆₇₈₉'[int(d)] for d in n])
        return f"A{subscript}"

    # Handle special names
    if name == 'Trivial':
        return 'Trivial'
    if name == 'V4':
        return 'ℤ₂²'

    # Default: return as-is
    return name


def format_rational(rat_str):
    """Format rational number strings like 'mkRat 1 3' or '(1 : Rat)/3' into fractions."""
    # Handle old format: mkRat 1 3
    if rat_str.startswith('mkRat '):
        parts = rat_str.split()
        if len(parts) == 3:
            num, denom = parts[1], parts[2]
            if denom == '1':
                return num
            return f"{num}/{denom}"

    # Handle new format: (1 : Rat)/3 or just an integer
    if '/' in rat_str:
        # Extract numerator and denominator from format like "(1 : Rat)/3"
        match = re.match(r'\((\d+)\s*:\s*Rat\)/(\d+)', rat_str)
        if match:
            num, denom = match.group(1), match.group(2)
            if denom == '1':
                return num
            return f"{num}/{denom}"

    # Handle plain integers
    if rat_str.isdigit():
        return rat_str

    return rat_str


def generate_html(groups, group_info, all_groups_tsv):
    """Generate HTML page with group table sectioned by order, including unimplemented groups."""
    # Group by order - include ALL groups from TSV
    by_order = defaultdict(list)
    for (order, gap_id), tsv_data in all_groups_tsv.items():
        # Get stats if implemented
        stats = groups.get((order, gap_id), {})
        by_order[order].append((gap_id, stats, tsv_data))

    # Calculate statistics - count implemented groups
    complete_orders = []
    partial_orders = []
    incomplete_orders = []  # Orders with any unimplemented groups
    implemented_count_by_order = {}

    for order in sorted(by_order.keys()):
        groups_in_order = by_order[order]
        implemented = sum(1 for _, stats, tsv_data in groups_in_order if tsv_data['implemented'])
        total_in_order = len(groups_in_order)
        implemented_count_by_order[order] = implemented

        if implemented == total_in_order:
            complete_orders.append(order)
        else:
            incomplete_orders.append(order)
            if implemented > 0:
                partial_orders.append((order, implemented, total_in_order))

    # Build mapping of incomplete order -> next incomplete order
    next_incomplete = {}
    for i, order in enumerate(incomplete_orders):
        if i + 1 < len(incomplete_orders):
            next_incomplete[order] = incomplete_orders[i + 1]

    total_expected = sum(len(by_order[order]) for order in by_order.keys())
    total_actual = len(groups)
    percentage = (total_actual / total_expected * 100) if total_expected > 0 else 0

    total_orders = len(by_order)

    html = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Small Groups Table</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            max-width: 1400px;
            margin: 40px auto;
            padding: 0 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
        }
        .summary {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 18px;
        }
        .summary strong {
            color: #4CAF50;
        }
        .order-section {
            margin-bottom: 40px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .order-header {
            padding: 15px 20px;
            font-size: 18px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .order-header.complete {
            background-color: #4CAF50;
            color: white;
        }
        .order-header.partial {
            background-color: #FF9800;
            color: white;
        }
        .progress {
            font-size: 14px;
            font-weight: normal;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #f0f0f0;
        }
        th {
            background-color: #f9f9f9;
            color: #333;
            font-weight: 600;
        }
        tr:hover {
            background-color: #f5f5f5;
        }
        tr:last-child td {
            border-bottom: none;
        }
        tr.implemented {
            background-color: #f0f9f0;
        }
        tr.implemented:hover {
            background-color: #e8f5e8;
        }
        .abelian-yes {
            color: #4CAF50;
            font-weight: 600;
        }
        .abelian-no {
            color: #f44336;
            font-weight: 600;
        }
        .number {
            text-align: right;
        }
        .gap-id {
            font-family: 'Courier New', monospace;
            color: #666;
            font-size: 14px;
        }
        .group-name-cell {
            padding: 8px 15px;
        }
        .group-name {
            font-weight: 500;
            font-size: 16px;
            margin-bottom: 4px;
        }
        .group-abbrev {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #888;
            line-height: 1.3;
        }
        .jump-link {
            display: inline-block;
            padding: 8px 16px;
            margin: 20px 0;
            background-color: #2196F3;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-weight: 500;
            text-align: center;
        }
        .jump-link:hover {
            background-color: #1976D2;
        }
        .next-incomplete {
            font-size: 14px;
            font-weight: normal;
        }
        .next-incomplete a {
            color: white;
            text-decoration: underline;
        }
        .next-incomplete a:hover {
            text-decoration: none;
        }
        .top-nav {
            text-align: center;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <h1>Small Groups (Orders 1-60)</h1>
    <div class="summary">
        <strong>""" + f"{total_actual}/{total_expected}</strong> groups ({percentage:.1f}%) | " + f"""
        <strong>{len(complete_orders)}/{total_orders}</strong> complete orders
    </div>"""

    # Add jump link to first incomplete order
    if incomplete_orders:
        first_incomplete = incomplete_orders[0]
        html += f"""
    <div class="top-nav">
        <a href="#order-{first_incomplete}" class="jump-link">⚠ Jump to First Incomplete Order ({first_incomplete})</a>
    </div>
"""
    else:
        html += "\n"

    # Generate sections by order
    for order in sorted(by_order.keys()):
        groups_in_order = sorted(by_order[order], key=lambda x: x[0])
        total_in_order = len(groups_in_order)
        implemented_in_order = implemented_count_by_order.get(order, 0)
        is_complete = implemented_in_order == total_in_order

        header_class = "complete" if is_complete else "partial"
        status_icon = "✓" if is_complete else "⚠"

        # Build navigation for incomplete orders
        next_link = ""
        if not is_complete and order in next_incomplete:
            next_order = next_incomplete[order]
            next_link = f'<span class="next-incomplete"> | <a href="#order-{next_order}">Next incomplete: {next_order} →</a></span>'

        html += f"""
    <div class="order-section" id="order-{order}">
        <div class="order-header {header_class}">
            <span>{status_icon} Order {order}</span>
            <span class="progress">{implemented_in_order}/{total_in_order} groups{next_link}</span>
        </div>
        <table>
            <thead>
                <tr>
                    <th>GAP ID</th>
                    <th>Group Name</th>
                    <th>Abelian?</th>
                    <th>Exponent</th>
                    <th class="number">Frac. Involutions</th>
                    <th class="number">Commuting Fraction</th>
                    <th class="number"># Subgroups</th>
                    <th class="number">Upper Central Series</th>
                </tr>
            </thead>
            <tbody>
"""

        for gap_id, data, tsv_data in groups_in_order:
            label = tsv_data['label']
            implemented = tsv_data['implemented']

            if implemented and data:
                # Implemented group - show full stats
                abelian = data.get('abelian', '?')
                exponent = data.get('exponent', '?')
                frac_inv = format_rational(data.get('frac_involutions', '?'))
                comm_frac = format_rational(data.get('commuting_fraction', '?'))
                num_subgroups = data.get('num_subgroups', '?')
                z1size = data.get('z1size', '?')
                z2size = data.get('z2size', '?')
                z3size = data.get('z3size', '?')
                z4size = data.get('z4size', '?')

                # Build upper central series list - stops when values stop changing
                z_chain = []
                if z1size != '?':
                    z_chain.append(z1size)
                    if z2size != '?' and z2size != z1size:
                        z_chain.append(z2size)
                        if z3size != '?' and z3size != z2size:
                            z_chain.append(z3size)
                            if z4size != '?' and z4size != z3size:
                                z_chain.append(z4size)
                z_series = '[' + ', '.join(z_chain) + ']' if z_chain else '?'

                abelian_class = 'abelian-yes' if abelian == 'true' else 'abelian-no'
                abelian_text = 'Yes' if abelian == 'true' else 'No'

                # Get formatted group name and abbrev from Lean file
                info = group_info.get((order, gap_id), {})
                lean_name = info.get('name', '')
                lean_def = info.get('definition', '')

                group_name = format_group_name_html(lean_name) or f"Gap({order}, {gap_id})"

                # Format the abbrev line
                abbrev_line = f"abbrev {lean_name} := {lean_def}" if lean_name and lean_def else ""
            else:
                # Unimplemented group - show label, blank stats
                abelian_class = ''
                abelian_text = '-'
                frac_inv = '-'
                comm_frac = '-'
                num_subgroups = '-'
                z_series = '-'
                group_name = label
                exponent = '-'
                abbrev_line = f'<span style="color: #999; font-style: italic;">Not implemented</span>'

            row_class = "implemented" if implemented else ""
            html += f"""                <tr class="{row_class}">
                    <td class="gap-id">({order}, {gap_id})</td>
                    <td class="group-name-cell">
                        <div class="group-name">{group_name}</div>
                        <div class="group-abbrev">{abbrev_line}</div>
                    </td>
                    <td class="{abelian_class}">{abelian_text}</td>
                    <td>{exponent}</td>
                    <td class="number">{frac_inv}</td>
                    <td class="number">{comm_frac}</td>
                    <td class="number">{num_subgroups}</td>
                    <td class="number">{z_series}</td>
                </tr>
"""

        html += """            </tbody>
        </table>
    </div>
"""

    html += """</body>
</html>
"""
    return html


def main():
    """Main function."""
    # Load all groups from TSV (implemented and unimplemented)
    print("Loading all groups from TSV file...")
    all_groups_tsv = load_all_groups_from_tsv()
    total_groups = len(all_groups_tsv)
    implemented_groups = sum(1 for g in all_groups_tsv.values() if g['implemented'])
    print(f"Found {total_groups} groups total, {implemented_groups} implementable")

    # Load statistics from JSON
    print("Loading statistics from group_stats.json...")
    try:
        groups, group_info = load_stats_from_json()
        print(f"Loaded {len(groups)} groups with computed statistics")
    except FileNotFoundError:
        print("ERROR: group_stats.json not found!")
        print("Please run 'python3 collect_group_stats.py' first to collect statistics.")
        return

    # Generate HTML
    print("Generating HTML table...")
    html = generate_html(groups, group_info, all_groups_tsv)

    # Write to file
    output_file = Path("groups_table.html")
    output_file.write_text(html)
    print(f"HTML table written to {output_file.absolute()}")


if __name__ == "__main__":
    main()
