import Mathlib.Data.List.MinMax
import Mathlib.Data.Nat.Log
import Mathlib.Order.WithBot
import Plausible

set_option autoImplicit false

namespace Cslib.Algorithms.Lean.TimeM

-- minimum of xs[l..r] inclusive
def rmqNaive (xs : Array ℕ) (l r : ℕ) : WithTop ℕ :=
  (xs.drop l |>.take (r - l + 1)).toList.minimum

/-
# Sparse Table

Define a structure SparseTable which preprocesses an array of integers for fast RMQ queries.
- make : Array ℕ → SparseTable
- query : SparseTable → ℕ → ℕ → ℕ
-/

structure SparseTable where
  table : Array (Array ℕ)

def SparseTable.make (a : Array ℕ) : SparseTable := {
  table :=
    if a.size == 0 then #[]
    else
      let n := a.size
      let k := Nat.log 2 n + 1
      (List.range (k - 1)).foldl (fun st i =>
        let i := i + 1
        let half := 2 ^ (i - 1)
        let rowLen := n - 2 ^ i + 1
        let prev := st[i - 1]!
        st.push ((Array.range rowLen).map fun j => min prev[j]! prev[j + half]!)
      ) #[a]
}

def SparseTable.query (st : SparseTable) (l r : ℕ) : ℕ :=
  let len := r - l + 1
  let k := Nat.log 2 len
  min st.table[k]![l]! st.table[k]![r + 1 - 2 ^ k]!

/-
# Quickcheck of SparseTable.make

Check that SparseTable.make generates the correct table as the python code (verification by eval'ing examples).
Expected values obtained via: echo "3 1 4 1 5 9 2 6" | python3 sparsetable.py
-/

/--info: true-/ #guard_msgs in
#eval (SparseTable.make #[3, 1, 4, 1, 5, 9, 2, 6]).table == #[#[3, 1, 4, 1, 5, 9, 2, 6], #[1, 1, 1, 1, 5, 2, 2], #[1, 1, 1, 1, 2], #[1]]

/--info: true-/ #guard_msgs in
#eval (SparseTable.make #[5]).table == #[#[5]]

/--info: true-/ #guard_msgs in
#eval (SparseTable.make #[10, 20]).table == #[#[10, 20], #[10]]

/--info: true-/ #guard_msgs in
#eval (SparseTable.make #[7, 2, 9, 4, 3, 1, 8]).table == #[#[7, 2, 9, 4, 3, 1, 8], #[2, 2, 4, 3, 1, 1], #[2, 2, 1, 1]]

/-
# Verification of SparseTable.query

Formally prove that SparseTable solves the RMQ problem.
-/

/-- Minimum of a sublist: xs[start .. start+len-1] -/
def rangeMin (xs : List ℕ) (start len : ℕ) : WithTop ℕ :=
  (xs.drop start |>.take len).minimum

/-- Splitting a contiguous range into two parts -/
lemma rangeMin_split (xs : List ℕ) (j a b : ℕ) :
    rangeMin xs j (a + b) = min (rangeMin xs j a) (rangeMin xs (j + a) b) := by
  unfold rangeMin
  rw [List.take_add, List.minimum_append, List.drop_drop]

/-- Two overlapping ranges of length 2^k cover a range of length len -/
lemma rangeMin_overlap (xs : List ℕ) (l len k : ℕ)
    (hk : 2 ^ k ≤ len) (hlen : len < 2 ^ (k + 1)) :
    min (rangeMin xs l (2 ^ k)) (rangeMin xs (l + len - 2 ^ k) (2 ^ k))
    = rangeMin xs l len := by
  set s := len - 2 ^ k with hs_def
  have hs_lt : s < 2 ^ k := by omega
  have hlen_eq : s + 2 ^ k = len := by omega
  have haddr : l + len - 2 ^ k = l + s := by omega
  -- Decompose the left range: 2^k = s + (2^k - s)
  have hleft : rangeMin xs l (2 ^ k) =
      min (rangeMin xs l s) (rangeMin xs (l + s) (2 ^ k - s)) := by
    conv_lhs => rw [show 2 ^ k = s + (2 ^ k - s) from by omega]
    exact rangeMin_split xs l s (2 ^ k - s)
  -- Decompose the right range: 2^k = (2^k - s) + s
  have hright : rangeMin xs (l + s) (2 ^ k) =
      min (rangeMin xs (l + s) (2 ^ k - s)) (rangeMin xs (l + 2 ^ k) s) := by
    conv_lhs => rw [show 2 ^ k = (2 ^ k - s) + s from by omega]
    rw [rangeMin_split]
    congr 1
    congr 1
    omega
  -- Rewrite goal
  rw [haddr, ← hlen_eq, rangeMin_split xs l s (2 ^ k), hleft, hright]
  -- Goal: min (min pA pB) (min pB pC) = min pA (min pB pC)
  rw [min_assoc]
  congr 1
  rw [← min_assoc, min_self]

/-- Recursive version of table construction, equivalent to foldl -/
private def buildTable (a : Array ℕ) : ℕ → Array (Array ℕ)
  | 0 => #[a]
  | m + 1 =>
    let st := buildTable a m
    st.push ((Array.range (a.size - 2 ^ (m + 1) + 1)).map fun j =>
      min st[m]![j]! st[m]![j + 2 ^ m]!)

private lemma buildTable_size (a : Array ℕ) : ∀ m, (buildTable a m).size = m + 1
  | 0 => by simp [buildTable]
  | m + 1 => by simp [buildTable, buildTable_size a m]

private lemma rangeMin_one (xs : List ℕ) (j : ℕ) (hj : j < xs.length) :
    rangeMin xs j 1 = ↑(xs[j]) := by
  unfold rangeMin
  rw [List.drop_eq_getElem_cons hj, show (1:ℕ) = 0 + 1 from rfl, List.take_add_one,
    List.getElem?_cons_zero, Option.toList, List.take_zero, List.nil_append,
    List.minimum_singleton]

private lemma foldl_eq_buildTable (a : Array ℕ) (f : Array (Array ℕ) → ℕ → Array (Array ℕ))
    (hf : ∀ st idx, f st idx = st.push ((Array.range (a.size - 2 ^ (idx + 1) + 1)).map fun j =>
      min st[idx]![j]! st[idx]![j + 2 ^ idx]!)) :
    ∀ m, (List.range m).foldl f #[a] = buildTable a m
  | 0 => by simp [buildTable]
  | m + 1 => by
    rw [List.range_succ, List.foldl_append, List.foldl_cons, List.foldl_nil,
      foldl_eq_buildTable a f hf m, hf, buildTable]

private lemma buildTable_eq_make (a : Array ℕ) (ha : 0 < a.size) :
    (SparseTable.make a).table = buildTable a (Nat.log 2 a.size) := by
  simp only [SparseTable.make, beq_iff_eq]
  split
  · omega
  · next hne =>
    show (List.range (Nat.log 2 a.size + 1 - 1)).foldl _ #[a] = _
    rw [show Nat.log 2 a.size + 1 - 1 = Nat.log 2 a.size from by omega]
    exact foldl_eq_buildTable a _ (fun st idx => rfl) _

private lemma buildTable_row_size (a : Array ℕ) (m : ℕ) (hm : 2 ^ m ≤ a.size)
    (i : ℕ) (hi : i ≤ m) :
    ((buildTable a m)[i]'(by rw [buildTable_size]; omega)).size = a.size - 2 ^ i + 1 := by
  induction m with
  | zero =>
    have hi0 : i = 0 := by omega
    subst hi0
    simp [buildTable]; omega
  | succ m ih =>
    by_cases him : i ≤ m
    · have hlt : i < (buildTable a m).size := by rw [buildTable_size]; omega
      simp only [buildTable]
      rw [Array.getElem_push_lt hlt]
      exact ih (le_trans (Nat.pow_le_pow_right (by omega) (Nat.le_succ m)) hm) him
    · have him_eq : i = m + 1 := by omega
      subst him_eq
      simp [buildTable, Array.getElem_push, buildTable_size, Array.size_map, Array.size_range]

private theorem buildTable_invariant (a : Array ℕ) (m : ℕ)
    (hm : 2 ^ m ≤ a.size) (i j : ℕ) (hi : i ≤ m) (hj : j + 2 ^ i ≤ a.size) :
    ↑(((buildTable a m)[i]'(by rw [buildTable_size]; omega))[j]'(by
      rw [buildTable_row_size a m hm i hi]; omega)) =
      rangeMin a.toList j (2 ^ i) := by
  induction m generalizing i j with
  | zero =>
    have hi0 : i = 0 := by omega
    subst hi0
    simp only [buildTable, Nat.pow_zero]
    exact (rangeMin_one a.toList j (by simp; omega)).symm
  | succ m ih =>
    have hm' : 2 ^ m ≤ a.size :=
      le_trans (Nat.pow_le_pow_right (by omega) (Nat.le_succ m)) hm
    by_cases him : i ≤ m
    · -- Old row preserved by push
      have hlt : i < (buildTable a m).size := by rw [buildTable_size]; omega
      have heq : (buildTable a (m + 1))[i]'(by rw [buildTable_size]; omega) =
                  (buildTable a m)[i]'hlt := by
        simp [buildTable, Array.getElem_push_lt hlt]
      simp only [heq]
      exact ih hm' i j him hj
    · -- New row (i = m + 1)
      have him_eq : i = m + 1 := by omega
      subst him_eq
      -- Prepare bounds
      have pow_eq : 2 ^ (m + 1) = 2 ^ m + 2 ^ m := by grind
      have hm_lt : m < (buildTable a m).size := by rw [buildTable_size]; omega
      have hrow_sz : ((buildTable a m)[m]'hm_lt).size = a.size - 2 ^ m + 1 :=
        buildTable_row_size a m hm' m le_rfl
      have hj_lt : j < ((buildTable a m)[m]'hm_lt).size := by rw [hrow_sz]; grind
      have hjp_lt : j + 2 ^ m < ((buildTable a m)[m]'hm_lt).size := by
        rw [hrow_sz]; omega
      -- IH applications
      have ih1 := ih hm' m j (le_refl m) (show j + 2 ^ m ≤ a.size by omega)
      have ih2 := ih hm' m (j + 2 ^ m) (le_refl m) (show (j + 2 ^ m) + 2 ^ m ≤ a.size by omega)
      -- Rewrite RHS using rangeMin_split and IH
      conv_rhs => rw [pow_eq]
      rw [rangeMin_split, ← ih1, ← ih2, ← WithTop.coe_min]
      -- Both sides are ↑(something), remove ↑
      congr 1
      -- LHS: (buildTable a (m+1))[m+1][j]
      -- RHS: min (buildTable a m)[m][j] (buildTable a m)[m][j + 2^m]
      simp [buildTable, Array.getElem_push, buildTable_size,
            Array.getElem_map, Array.getElem_range, getElem!_pos]
      grind

/-- Each table entry stores the range minimum for a power-of-2 length -/
theorem table_invariant (a : Array ℕ) (ha : 0 < a.size) (i j : ℕ)
    (hi : i < (SparseTable.make a).table.size)
    (hj : j < ((SparseTable.make a).table[i]).size) :
    (((SparseTable.make a).table[i])[j]) = rangeMin a.toList j (2 ^ i) := by
  simp only [buildTable_eq_make a ha]
  apply buildTable_invariant
  sorry
  sorry
  sorry

theorem correct (vals : Array ℕ) (l r : ℕ) (h : l ≤ r) (hr : r < vals.size)
: (SparseTable.make vals).query l r = rmqNaive vals l r := by sorry

/-
# Quickcheck of SparseTable.query
-/

def randArray (size : ℕ) : IO (Array ℕ) := do
  let mut arr : Array ℕ := #[]
  for _ in [:size] do
    let v ← IO.rand 0 200
    arr := arr.push v
  return arr

def SparseTable.verifyOne (vals : Array ℕ) : Bool :=
  let st := SparseTable.make vals
  Id.run do
    let mut ok := true
    for l in [:vals.size] do
      for r in [l:vals.size] do
        if rmqNaive vals l r != ↑(st.query l r) then
          ok := false
    return ok

def SparseTable.verify : IO Bool := do
  IO.setRandSeed 42
  let mut ok := true
  for sz in [1:51] do
    let arr ← randArray sz
    if !SparseTable.verifyOne arr then
      ok := false
  return ok

/--info: true-/ #guard_msgs in #eval SparseTable.verify



end Cslib.Algorithms.Lean.TimeM
